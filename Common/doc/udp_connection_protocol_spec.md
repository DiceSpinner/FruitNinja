## UDPConnection Protocol Specification

### Overview

This document defines the message-level protocol used by the `UDPConnection` class for optionally reliable, bi-directional communication over UDP. Like TCP, multiple independent connections can be established and maintained simultaneously over a single UDP socket. Reliability is optional â€” packets sent without any flags are treated as normal, unreliable UDP packets with no acknowledgment or retry behavior.

### Usage

`UDPConnectionManager` is the primary interface for creating and managing connections over a single UDP socket. It handles initial connection setup, retry logic, and packet routing. After a `UDPConnection` is created, it is handed off to the application, which is responsible for monitoring connection state, sending and receiving packets, and initiating disconnects.

`UDPConnectionManager` owns a `UDPSocket` instance and spawns a single internal **router thread**, which handles all background logic:

- The router thread is responsible for invoking `UDPSocket::Read()` at regular intervals. When a packet is received, it is immediately dispatched to the appropriate `UDPConnection`. Before dispatch, the system verifies that the received packet contains at least `sizeof(UDPHeader)` bytes of payload. Any packet that fails this validation check is discarded immediately, ensuring that malformed or truncated datagrams are not processed.
- Incoming UDP packets are polled directly from the OS socket using a non-blocking `select()` based `recvfrom()` loop. No listener thread or intermediate user-space packet queue is used.
- The router thread also periodically updates all active connections to handle retries, retransmissions, and connection timeouts. This update interval is configurable at construction time.

It is templated with a parameter indicating the maximum number of concurrent connections (including in-progress handshakes). If this limit is reached, `ConnectPeer()` and `Accept()` will return default-constructed `std::shared_ptr<UDPConnection>`.

The packet queue capacity must be specified when constructing a `UDPConnectionManager`. If the queue is too small, packets may be dropped before they can be routed, especially during bursts of traffic.

#### Client Workflow:
1. The client initiates a connection using `UDPConnectionManager::ConnectPeer(sockaddr_in)`.
2. This triggers the connection handshake and immediately returns a `std::shared_ptr<UDPConnection>`. The client must check the connection state manually to determine when it becomes connected.
3. The client can then send and receive packets using `Send()` and `Receive()`. The connection state can be queried using `Connected()` and `Closed()`. `Disconnect()` can be called to terminate the connection.

#### Server Workflow:
1. The server listens for incoming handshakes. To do so, the `UDPConnectionManager::isListening` flag must be set to `true`.
2. Incoming connections can be accepted using `UDPConnectionManager::Accept()`.
3. This returns a `std::shared_ptr<UDPConnection>` once a handshake request is received. The connection continues to be established asynchronously.
4. The server must monitor the connection using `Connected()` and `Closed()`, and may call `Disconnect()` to explicitly close it.

---

### Connection Handshake

UDPConnection establishes a session between peers using a handshake protocol that ensures both sides agree on a shared session identifier (`sessionID`). This session ID acts as a persistent identifier for the connection, enabling reliable recognition of peer identity even when their IP address changes due to network interface switching (e.g., Wi-Fi to Ethernet). 

The use of `sessionID` also prevents ghosting issues, where stale packets from a previously closed connection might be misinterpreted as part of a new session. By verifying the session ID on every incoming packet, the system ensures that only packets from a valid, actively tracked connection are processed.

To further support mobility and NAT traversal, the IP address used to send responses is updated to match the source of the most recently received valid packet. This mechanism ensures continued communication with a moving peer while maintaining session integrity.

#### Handshake Packet Exchange:
1. **Client sends SYN**
   - A packet with the `SYN` flag and a randomly generated sessionID is sent to initiate the connection.
2. **Server replies with SYN|ACK**
   - The server responds with a `SYN | ACK` packet containing the confirmed sessionID. The sessionID is generated by the server and overrides the client's temporary one. The server includes the client's original sessionID in the packet header to ensure the client can match the response.
3. **Client sends ACK**
   - The client acknowledges the handshake with an `ACK` packet. After this, the connection is considered established.

#### SessionID Handling:
- The server has the final authority on the sessionID. The client generates a temporary sessionID when initiating the handshake, but it must adopt the sessionID provided by the server in the `SYN | ACK` reply.
- The `sessionID` is included in all subsequent packets to associate them with the active connection.
- Packets with incorrect or mismatched sessionIDs are discarded.

---

### Connection Retry

UDPConnection includes built-in retry mechanisms to handle packet loss during the connection handshake.

#### Client Behavior:
- After sending the initial `SYN`, the client enters the `Connecting` state.
- If no `SYN | ACK` is received within `connectionRetryInterval`, the client resends the `SYN`.
- If the client is already in the `Connected` state and receives a packet with the `SYN` flag, it indicates the server did not receive the final acknowledgment. In response, the client must retransmit the `ACK` to complete the handshake.
- Retries continue until `connectionTimeout` is reached, at which point the attempt is abandoned.

#### Server Behavior:
- Upon receiving a `SYN`, the server enters the `Pending` state and sends a `SYN | ACK` response.
- If no final `ACK` from the client is received:
  - The server resends the `SYN | ACK` to ensure delivery.
  - The server will also resend a plain `SYN` in case the final `ACK` was dropped, since the client's `sessionID` would have been updated to match the server's and will not be recognized by the server until the ACK is received.
- These retries also continue until the configured timeout is reached.

#### Timeout Behavior:
- Both sides will drop the connection attempt if the handshake is not completed within `connectionTimeout`.

---

### Connection Teardown

Connections are closed using the `FIN` flag, which signals connection termination.

#### FIN Behavior:
- When a connection sends a `FIN` packet, it is immediately marked as closed.
- All pending request futures (`std::future<std::optional<UDPPacket>>`) will be completed with `std::nullopt`.
- If a `FIN` packet is received, the receiving side will also immediately mark the connection as closed and fulfill all pending requests with `std::nullopt`.
- There is no retransmission for `FIN` packets. If the `FIN` packet is lost, the remote side will eventually timeout and clean up the connection.

---

### Packet Structure
Each packet consists of:

- **Header** (`UDPHeader`): Serialized at the beginning of the payload
- **Payload**: Application-defined data

#### `UDPHeader` Fields:
| Field       | Type      | Description |
|-------------|-----------|-------------|
| `index`     | `uint32_t` | Unique packet index per connection (used for ordering, deduplication, and response matching). Handled automatically by the transport layer. |
| `sessionID` | `uint32_t` | Session identifier assigned during connection handshake. Managed by the transport layer. |
| `ackIndex`  | `uint32_t` | Index of packet this message acknowledges (used in ACK packets) |
| `flag`      | `uint8_t`  | See flag definitions below |

---

### Timeout Configuration

Timeout behavior and retry intervals for both connection handshakes and request handling can be configured using the `TimeoutSetting` struct. This struct is passed when calling `UDPConnectionManager::ConnectPeer()` or `Accept()` and includes the following parameters:
- `connectionTimeout`: Maximum time to complete the handshake
- `connectionRetryInterval`: How long to wait before resending a handshake packet if no valid communication has been received
- `requestTimeout`: Time after which an unanswered request is considered failed
- `requestRetryInterval`: How long to wait before resending a request packet if no valid response has been received
- `impRetryInterval`: How long to wait before resending an `IMP` packet if no acknowledgment has been received

---

### Request Handling

Requests are initiated by sending a packet with the `REQ` flag set. Each request is associated with a unique packet index. The sender receives a `std::future<std::optional<UDPPacket>>`, which will complete when a matching response arrives or a timeout occurs.

Requests marked with `REQ` will be retransmitted automatically at intervals until a response is received or the request times out.

If the request times out, the associated `std::future` will be fulfilled with `std::nullopt` to indicate failure.

It is valid for a response to a `REQ` to itself be another `REQ`, enabling nested or conversational message patterns.

---

### Flag Semantics (`UDPHeaderFlag`)

#### Application-level Flags:
| Flag   | Description |
|--------|-------------|
| `None` | No special handling. Packets with no flags are sent and received like standard UDP packets, with no reliability or acknowledgment guarantees. |
| `REQ`  | Indicates this is a request expecting a response. Retries until a response is received or timeout. No ACK is required. |
| `IMP`  | Indicates reliable delivery is required. An ACK is expected; otherwise, the packet will be retransmitted. Cannot be used with `REQ`. |
| `ACK`  | Acknowledges receipt of a packet identified by `ackIndex`. May be used by application logic to acknowledge `REQ` packets. ACKs for `IMP` packets are handled automatically by the `UDPConnection`. |

#### Internal-use Flags (DO NOT USE directly):
| Flag  | Description |
|-------|-------------|
| `SYN` | Used in connection setup |
| `FIN` | Used to notify connection termination |
| `HBT` | Heartbeat packet to check if connection is alive |

#### Invalid Combinations:
- `REQ | IMP` â†’ **Invalid**. `REQ` already guarantees delivery through its own retry mechanism; combining with `IMP` is redundant and unsupported.
- `IMP | ACK` â†’ **Reserved**. Used internally to acknowledge an `IMP` packet and should not be set manually by application code.
